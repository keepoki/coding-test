"""
## 난이도
브론즈-2

## 알고리즘 분류
수학

## 문제
위의 그림과 같이 육각형으로 이루어진 벌집이 있다. 그림에서 보는 바와 같이 중앙의 방 1부터
시작해서 이웃하는 방에 돌아가면서 1씩 증가하는 번호를 주소로 매길 수 있다. 숫자 N이
주어졌을 때, 벌집의 중앙 1에서 N번 방까지 최소 개수의 방을 지나서 갈 때 몇 개의 방을
지나가는지(시작과 끝을 포함하여)를 계산하는 프로그램을 작성하시오. 예를 들면,
13까지는 3개, 58까지는 5개를 지난다.

## 입력
첫째 줄에 N(1 ≤ N ≤ 1,000,000,000)이 주어진다.

## 출력
입력으로 주어진 방까지 최소 개수의 방을 지나서 갈 때 몇 개의 방을 지나는지 출력한다.

## 문제 요약
중앙 1에서 N번 방까지 최소 개수의 방을 지나서 갈 때 몇 개의 방을 지나는지 구하기

## 풀이 과정
벌집의 크기는 6의 배수로 증가하고 있다.
1 -> 2 ~ 7 -> 8 ~ 19 -> 20 ~ 37 (+6 -> +12 -> +18)

1. 값이 1보다 클 때까지 반복해서 6의 배수 * i을 값에 계속해서 빼면서 카운트하고
1보다 작아지면 카운트를 출력하고 반복문을 빠져나온다.

## 풀이 요약
벌집의 각 겹(layer)마다 방의 개수가 6의 배수(6, 12, 18, ...)로 증가하는 패턴을 이용하여,
주어진 N이 몇 번째 겹에 속하는지 계산하면 됩니다.

## 시간 복잡도: O(√N), 공간 복잡도: O(1)

## 제출 결과
32412 KB 40 ms
## 점검

"""

n = int(input())
count = 1
while n > 1:
    n -= 6 * count
    count += 1

print(count)


"""
Gemini 2.5 Flash의 풀이
"""
# n = int(input())

# # 1번 방은 1개의 방을 지남
# if n == 1:
#     print(1)
# else:
#     # 겹(layer) 수를 나타내는 변수, 2번째 겹부터 시작
#     layer_count = 2
#     # 이전 겹의 마지막 방 번호
#     last_number = 1

#     while True:
#         # 현재 겹의 마지막 방 번호 계산
#         # 각 겹은 이전 겹의 마지막 방 번호에 (6 * (layer_count - 1))을 더해 확장됨
#         last_number += 6 * (layer_count - 1)

#         # N이 현재 겹의 마지막 방 번호보다 작거나 같으면, N은 현재 겹에 속함
#         if n <= last_number:
#             print(layer_count)
#             break

#         layer_count += 1
