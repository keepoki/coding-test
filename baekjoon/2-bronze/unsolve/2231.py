"""
## 난이도
브론즈-2

## 알고리즘 분류
브루트포스 알고리즘

## 문제
어떤 자연수 N이 있을 때, 그 자연수 N의 분해합은 N과 N을 이루는 각 자리수의 합을 의미한다.
어떤 자연수 M의 분해합이 N인 경우, M을 N의 생성자라 한다. 예를 들어, 245의 분해합은
256(=245+2+4+5)이 된다. 따라서 245는 256의 생성자가 된다. 물론, 어떤 자연수의 경우에는
생성자가 없을 수도 있다. 반대로, 생성자가 여러 개인 자연수도 있을 수 있다.

자연수 N이 주어졌을 때, N의 가장 작은 생성자를 구해내는 프로그램을 작성하시오.

## 입력
첫째 줄에 자연수 N(1 ≤ N ≤ 1,000,000)이 주어진다.

## 출력
첫째 줄에 답을 출력한다. 생성자가 없는 경우에는 0을 출력한다.

## 문제 요약
자연수 N의 가장 작은 생성자 M을 찾아야 한다. 생성자는 없을 수도 있다.

## 풀이 과정
제한 시간 10분 안에 풀지 못하여 Gemini-2.5 Flash의 풀이를 분석한다.

브루트포스(완전 탐색) 알고리즘을 사용하여 해결합니다.주어진 자연수 N의 가장 작은 생성자를
찾기 위해, 1부터 N까지의 모든 정수 M을 후보로 차례대로 검사합니다. 각 M에 대해 M 자신과
그 자릿수들을 모두 더하는 분해합을 계산합니다. 계산된 분해합이 N과 정확히 일치하면, 현재의
M이 우리가 찾는 가장 작은 생성자이므로, 이 M을 반환하고 탐색을 즉시 종료합니다.
만약 1부터 N까지 모든 수를 검사했음에도 불구하고 N과 일치하는 분해합을 가진 M을 찾지
못했다면, N의 생성자는 존재하지 않는 것이므로 0을 반환합니다.

## 풀이 요약
1부터 N까지 모든 숫자에 대해 분해합을 계산하며 N과 일치하는 가장 작은 숫자를 찾아
반환하고, 없으면 0을 반환합니다.

## 시간 복잡도: O(n log n), 공간 복잡도: O(1)

## 제출 결과
32412 KB 576 ms

## 점검
1부터 N까지 각 자리수를 더해서 N과 같은지 확인하는 간단한 문제였지만,
프루트포스 알고리즘이라는 생소한 개념을 접하게 되면서 복잡한 생각을 했던 것 같다.

각 자리의 가장 큰 숫자가 9이고, 모두 9일 때 [N의 길이 * 9]정도 M이 N보다 작을
수 있다고 판단하고 풀이를 도전하는데, 어떻게 구현해야 할지는 잘 그려지지 않았고,
제한 시간이 지나서 풀이에 실패하였다.

그런데 Gemini-2.5 Flash의 최적화 풀이를 보고나서야 내가 원하던 방식의 풀이와
일치하는 것을 보고, 더 깊이 있게 이해하려고 꼼꼼히 살펴보았다.

그래도 틀린 문제이니, 언젠가 다시 도전한다.
"""


def find_generator(n: int) -> int:
    """
    주어진 자연수 N의 가장 작은 생성자를 찾습니다.
    """
    # 생성자는 N보다 작거나 같을 것이므로, 1부터 N까지 모든 수를 M 후보로 확인합니다.
    # 하지만 M의 각 자릿수를 더하면 최소 1이 더해지므로, M은 N보다 작을 수밖에 없습니다.
    # 예를 들어 N이 256이라면, M의 최대 자릿수가 6개(999999)라고 가정할 때,
    # 999999 + (9*6) = 1000053 이므로 N이 100만일 경우 M은 대략 100만 - 9*7 = 999937 정도까지 찾아봐도 충분합니다.
    # 그러나 이 문제에서는 굳이 최적화하지 않고 N까지 모두 탐색해도 시간 제약(1초) 내에 해결됩니다.

    for m in range(1, n + 1):
        # 현재 M의 분해합을 계산합니다.
        # M 자신에다가 각 자릿수를 더합니다.
        decomposition_sum = m
        temp_m = m  # 자릿수 합을 계산하기 위한 임시 변수

        # 각 자릿수를 더하는 과정
        while temp_m > 0:
            decomposition_sum += temp_m % 10  # 마지막 자릿수를 더함
            temp_m //= 10  # 마지막 자릿수를 제거

        # 분해합이 N과 같은지 확인
        if decomposition_sum == n:
            return m  # 가장 작은 생성자를 찾았으므로 즉시 반환

    # 1부터 N까지 탐색했는데도 생성자를 찾지 못한 경우
    return 0


N = int(input())
result = find_generator(N)
print(result)


"""
Gemini-2.5 Flash의 최적화된 풀이

## 풀이 과정
주어진 자연수 N의 가장 작은 생성자 M을 찾기 위해, M이 N보다 최대 9 * (N의 자릿수)만큼
작을 수 있다는 점을 활용하여 탐색 시작 지점( N - 9 * len(str(N)) )을 계산합니다.
이후 이 시작 지점부터 N까지의 모든 정수 M을 후보로 차례대로 검사합니다. 각 M에 대해
분해합(M + M의 각 자릿수 합)을 계산하고, 이 분해합이 N과 일치하면 해당 M이 가장 작은
생성자이므로 이를 반환하고 종료합니다. 모든 후보를 확인했음에도 생성자를 찾지 못하면 0을
반환합니다.

## 풀이 요약
N의 자릿수를 고려하여 탐색 시작 지점을 최적화한 후, 해당 범위 내 모든 숫자에 대해 분해합을
계산하며 N과 일치하는 가장 작은 숫자를 찾아 반환하고, 없으면 0을 반환합니다.

## 시간 복잡도: O((log n)²), 공간 복잡도: O(1)

## 제출 결과
32412 KB 36 ms
"""

def find_generator_optimized(n: int) -> int:
    """
    주어진 자연수 N의 가장 작은 생성자를 찾습니다.
    탐색 범위를 최적화합니다.
    """
    # N의 자릿수를 구합니다. (예: N=256 -> len(str(N))=3)
    num_digits_n = len(str(n))

    # 생성자 M은 N - (M의 최대 자릿수 합) 보다 작을 수 없습니다.
    # M의 자릿수 합의 최대값은 N의 자릿수 * 9 (모든 자릿수가 9일 경우)
    # 예를 들어 N이 100만일 경우, N의 자릿수는 7 (1,000,000).
    # M은 최대 63 (9*7) 정도 N보다 작을 수 있습니다.
    
    # 탐색 시작 지점 설정: N - (최대 가능한 자릿수 합)
    # 이 값은 1보다 작아질 수 있으므로 max(1, ...)을 사용합니다.
    start_m = max(1, n - (9 * num_digits_n))

    for m in range(start_m, n + 1): # M은 N을 넘을 수 없습니다.
        # 현재 M의 분해합을 계산합니다.
        decomposition_sum = m
        temp_m = m

        while temp_m > 0:
            decomposition_sum += temp_m % 10
            temp_m //= 10

        # 분해합이 N과 같은지 확인
        if decomposition_sum == n:
            return m  # 가장 작은 생성자를 찾았으므로 즉시 반환

    # 생성자를 찾지 못한 경우
    return 0

# 입력 받기
N = int(input())

# 함수 호출 및 결과 출력
result = find_generator_optimized(N)
print(result)