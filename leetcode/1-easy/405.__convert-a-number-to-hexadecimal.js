/*
 * @lc app=leetcode id=405 lang=javascript
 *
 * [405] Convert a Number to Hexadecimal
 */

// @lc code=start
/**
 * * 뤼튼 AI의 풀이의 도움을 받고 분석하였다.
 * 32비트로 이루어진 정수 num이 주어지고 16진수로 변환된 문자열을 반환해야 한다.
 * 4개 비트로 나누어서 16진수로 변환하는 것은 알았지만, 음수에 대한 처리를 코드로
 * 어떻게 해야할지 몰랐는데 AND연산자와 16진수 숫자로 가져오는 방법을 배우게 됐다.
 * 부호 없는 시프트 이동(>>>)을 쓸일이 없어 몰랐지만 배우게 됐다.
 * 컴퓨터에서는 맨 왼쪽 첫 번째 비트를 양수와 음수에 대한 부호 비트로 사용된다.
 * 비트를 반전시키는 1의 보수에 1을 더한 값으로 2의 보수를 구한다.
 * 음수를 나타내기 위해 2의 보수를 사용한다.
 * 4비트로 제한하여 -1을 설명하자면, 1은 2진수로 0001, 1의 보수는 1110이다.
 * 1의 보수 1110 에서 0001을 더하면 1111이 된다. 이것이 2의 보수이다.
 * 따라서 -1은 모든 비트가 1로 채워진다.
 * 부호가 있는 8비트의 정수형 숫자는 -128 ~ 127 사이의 정수로 표현이 가능하다.
 * 첫 번째 비트는 부호이므로 7개의 2진수로만 숫자를 표현하는 것이다.
 * 부호가 없는 8비트의 정수형 숫자는 0 ~ 255 사이의 정수로 표현이 가능하다.
 * @param {number} num
 * @return {string}
 */
const toHex = (num) => {
  if (num === 0) return "0"; // 0의 경우 처리

  const hexChars = "0123456789abcdef"; // 16진수 문자
  let hexString = ""; // 16진수 표현을 저장할 문자열

  // 32비트 정수의 경우 최대 8자리의 16진수로 표현 가능
  for (let i = 0; i < 8; i++) {
    const remainder = num & 0xf; // 마지막 4비트 가져오기
    hexString = hexChars[remainder] + hexString; // 해당 16진수 문자 추가
    num >>>= 4; // 숫자를 4비트 오른쪽으로 이동 (부호 없는 오른쪽 시프트)

    // num이 0이 되면 반복 종료
    if (num === 0) break;
  }

  return hexString; // 결과 반환
};
// @lc code=end

console.log(toHex(26)); // 1a
console.log(toHex(-1)); // ffffffff

