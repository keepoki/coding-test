/*
 * @lc app=leetcode id=121 lang=javascript
 *
 * [121] Best Time to Buy and Sell Stock
 * Tags: array | dynamic-programming
 */

// @lc code=start
/**
 * ## 문제
 * 주식 최대 이익
 * prices 배열이 주어집니다. 여기서 prices[i]는 i번째 날의 주식 가격입니다.
 * 주식 하나를 살 날을 하루 정하고, 그 주식을 팔 다른 미래의 날을 하루 정하여 최대 이익을
 * 얻고 싶습니다. 이 거래로 얻을 수 있는 최대 이익을 반환하세요.
 * 만약 어떤 이익도 얻을 수 없다면, 0을 반환하세요.
 *
 * ## 예시
 * 예시 1:
 * 입력: prices = [7,1,5,3,6,4]
 * 출력: 5
 * 설명: 2일차(가격 = 1)에 사서 5일차(가격 = 6)에 팔면, 이익 = 6 - 1 = 5입니다.
 * 2일차에 사고 1일차에 파는 것은 허용되지 않습니다. 주식은 팔기 전에 사야 하기 때문입니다.
 *
 * 예시 2:
 * 입력: prices = [7,6,4,3,1]
 * 출력: 0
 * 설명: 이 경우, 거래를 통해 얻을 수 있는 이익이 없으므로 최대 이익은 0입니다.
 *
 * ## 제약 조건
 * 1. 1 <= prices.length <= 10^5
 * 2. 0 <= prices[i] <= 10^4
 *
 * ## 문제 요약
 * 구매한 요소는 왼쪽에 위치하고, 판매한 요소는 오른쪽 모든 요소들이다.
 * 판매한 요소에 구매한 요소를 뺀 값 중 가장 큰 값을 찾아서 반환한다.
 *
 * ## 풀이 과정
 * 1. 최대 값을 담을 변수를 초기화 한다.
 * 2. 왼쪽 요소에 대한 모든 오른쪽 요소들의 차이 값을 반복해서 구한다.
 * 3. 요소의 차이 값과 최대 값을 비교해서 값을 갱신 한다.
 * 4. 차이의 최대 값을 반환한다.
 * 5. 만약 이익이 없으면 0을 반환한다.
 *
 * 시간 초과로 풀이에 실패하여, 불필요한 계산을 줄이기 위한 최적화를 진행하였다.
 * 1. 최저 구매 금액과 현재 구매 금액과 비교하여 현재 구매 금액이 크면
 *    해당 구매에 대한 계산은 건너 뛴다.
 * 2. 판매 금액과 구매 금액을 비교하여 판매 금액보다 구매 금액이 크거나 같은 경우
 *    구매 금액을 판매 금액의 요소부터 탐색할 수 있도록 건너뛴다.
 *
 * ## 풀이 요약
 * 주식 배열을 한 번만 순회하기 위해 최저 구매 금액을 비교하고, 판매 금액과 구매 금액을
 * 비교하여 판매 금액보다 크거나 같은 구매 금액의 계산은 건너뛴다.
 * 판매 금액에서 구매 금액을 뺀 차이 값을 최대 차이 값을 기록하고 반환한다.
 *
 * ## 시간 복잡도: O(n), 공간 복잡도: O(1)
 *
 * ## 제출 결과
 * 212/212 cases passed (2 ms)
 * Your runtime beats 83.16 % of javascript submissions
 * Your memory usage beats 50.59 % of javascript submissions (65.1 MB)
 *
 * ## 점검
 * 다 풀고보니 굳이 2중 배열 탐색할 필요가 있었을까 싶은 생각이 들었다.
 * 그래서 더 최적화된 방식으로 다시 풀어보기로 한다.
 *
 * @param {number[]} prices
 * @return {number}
 */
const maxProfit = (prices) => {
  let max = 0;
  let minPurchasingPrice = Number.MAX_SAFE_INTEGER;
  
  for (let i = 0; i < prices.length - 1; i++) {
    const purchasingPrice = prices[i];

    if (purchasingPrice > minPurchasingPrice) {
      continue;
    }

    minPurchasingPrice = purchasingPrice;

    for (let j = i + 1; j < prices.length; j++) {
      const sellingPrice = prices[j];

      if (purchasingPrice >= sellingPrice) {
        i = j - 1;
        break;
      }

      max = Math.max(sellingPrice - purchasingPrice, max);
    }
  }

  return max;
};
// @lc code=end

// console.log(maxProfit([7, 1, 5, 3, 6, 4]));
// console.log(maxProfit([2, 2, 5]));

/**
 * ## 목표
 * 1차 배열 탐색으로 구현
 *
 * ## 풀이 과정
 * 다시는 구매한 요소의 순번으로 돌아갈 필요가 없기 때문에 1중 배열로도 충분히 가능하다고
 * 판단하였고, 최소 값을 기록하여 그 값과 비교하면 된다.
 *
 * ## 풀이 요약
 * 배열을 순회하여 최소 값을 기록하고, 현재 값 - 최소 값의 차이가 큰 값을 구하여 반환한다.
 *
 * ## 실행 순서 디버깅
 * +-------+-----------+-----------+-----------+------------------------------------------+
 * |   i   | prices[i] | minPrice  | maxProfit |               설명                        |
 * +-------+-----------+-----------+-----------+------------------------------------------+
 * | 초기값 |           | Infinity  |     0     | minPrice는 무한대, maxProfit은 0으로 초기화 |
 * +-------+-----------+-----------+-----------+------------------------------------------+
 * |   0   |     7     |     7     |     0     | 7 < Infinity, minPrice = 7               |
 * +-------+-----------+-----------+-----------+------------------------------------------+
 * |   1   |     1     |     1     |     0     | 1 < 7, minPrice = 1                      |
 * +-------+-----------+-----------+-----------+------------------------------------------+
 * |   2   |     5     |     1     |     4     | 5 > 1. (5 - 1) = 4. 4 > 0, maxProfit = 4 |
 * +-------+-----------+-----------+-----------+------------------------------------------+
 * |   3   |     3     |     1     |     4     | 3 > 1. (3 - 1) = 2. 2 < 4, maxProfit 유지 |
 * +-------+-----------+-----------+-----------+------------------------------------------+
 * |   4   |     6     |     1     |     5     | 6 > 1. (6 - 1) = 5. 5 > 4, maxProfit = 5 |
 * +-------+-----------+-----------+-----------+------------------------------------------+
 * |   5   |     4     |     1     |     5     | 4 > 1. (4 - 1) = 3. 3 < 5, maxProfit 유지 |
 * +-------+-----------+-----------+-----------+------------------------------------------+
 * |  최종  |           |           |     5     |                                          |
 * +-------+-----------+-----------+-----------+------------------------------------------+
 *
 * ## 시간 복잡도: O(n), 공간 복잡도: O(1)
 *
 * ## 제출 결과
 * 212/212 cases passed (2 ms)
 * Your runtime beats 83.16 % of javascript submissions
 * Your memory usage beats 50.59 % of javascript submissions (65.1 MB)
 */
const maxProfit2 = (prices) => {
  let minPrice = Infinity;
  let max = 0;

  for (let i = 0; i < prices.length; i++) {
    const price = prices[i];

    if (minPrice > price) {
      minPrice = price;
    } else if (price - minPrice > max) {
      max = price - minPrice;
    }
  }
  
  return max;
}

console.log(maxProfit2([7, 1, 5, 3, 6, 4]));